# -*- coding: utf-8 -*-\n\"\"\"\nST-CIML PyTorch 示例代码 - 组合损失函数\n\"\"\"\n\nimport torch\nimport torch.nn as nn\nfrom typing import Optional\n\n# 从 utils 导入设备\nfrom .utils import device\n\ndef calculate_combined_loss(predictions: torch.Tensor, targets: torch.Tensor,\n                            attributions: torch.Tensor, target_attributions: Optional[torch.Tensor] = None,\n                            physics_residual: Optional[torch.Tensor] = None,\n                            lambda_attr: float = 0.1, lambda_physics: float = 0.1,\n                            attr_loss_type: str = \'constraint\') -> torch.Tensor:\n    \"\"\"\n    计算组合损失函数。\n\n    Args:\n        predictions (torch.Tensor): 模型预测值。\n        targets (torch.Tensor): 真实目标值。\n        attributions (torch.Tensor): 模型输出的归一化归因。\n        target_attributions (Optional): 目标归因真值或约束。\n        physics_residual (Optional): 物理约束残差。\n        lambda_attr (float): 归因损失的权重。\n        lambda_physics (float): 物理损失的权重。\n        attr_loss_type (str): 归因损失类型 (\'constraint\', \'mse\', \'kl_div\', \'none\')。\n\n    Returns:\n        torch.Tensor: 加权组合后的总损失值 (标量)。\n    \"\"\"\n    # --- 形状对齐 --- #\n    # 目标通常是 B, T_pred, N, F_pred\n    # 预测可能是 B, N, F_pred (单步) 或 B, T_pred, N, F_pred\n    # 归因通常是 B, N, C 或 B, T_pred, N, C\n    # 目标归因通常是 B, T_pred, N, C\n    # 物理残差可能是 B, N, F_pred 或 B, T_pred, N, F_pred\n\n    T_pred = targets.shape[1] # 目标中的预测步数\n\n    # 对齐预测和目标\n    if predictions.dim() == 3 and targets.dim() == 4 and T_pred == 1:\n        targets = targets.squeeze(1) # B, 1, N, F_pred -> B, N, F_pred\n    elif predictions.dim() == 4 and targets.dim() == 3 and predictions.shape[1] == 1:\n        predictions = predictions.squeeze(1) # B, 1, N, F_pred -> B, N, F_pred\n    elif predictions.shape != targets.shape:\n        # 尝试广播或更复杂的对齐，或者直接报错\n        try:\n            # 如果预测是 (B, N, F) 而目标是 (B, T, N, F)，可能只预测最后一步？\n            if predictions.dim()==3 and targets.dim()==4 and predictions.shape[0]==targets.shape[0] and predictions.shape[1]==targets.shape[2] and predictions.shape[2]==targets.shape[3]:\n                 targets = targets[:,-1,:,:] # 取目标的最后时间步\n                 print(\"Warning: Targets shape adjusted to match predictions (assuming last step prediction)\")\n            else:\n                 raise ValueError(\"Cannot automatically align shapes.\")\n        except Exception as e:\n             raise ValueError(f\"Shape mismatch between predictions {predictions.shape} and targets {targets.shape}. Alignment failed: {e}\")\n\n    # 1. 预测损失 (Prediction Loss)\n    pred_loss_fn = nn.MSELoss()\n    loss_pred = pred_loss_fn(predictions, targets)\n\n    # 2. 归因损失 (Attribution Loss)\n    loss_attr = torch.tensor(0.0, device=device)\n    if lambda_attr > 0 and attr_loss_type != \'none\':\n        # 对齐归因和目标归因 (如果提供了目标归因)\n        if target_attributions is not None:\n            if attributions.dim() == 3 and target_attributions.dim() == 4 and target_attributions.shape[1] == 1:\n                target_attributions = target_attributions.squeeze(1)\n            elif attributions.dim() == 4 and target_attributions.dim() == 3 and attributions.shape[1] == 1:\
                attributions = attributions.squeeze(1)\n            elif attributions.shape != target_attributions.shape:\n                 try:\n                      if attributions.dim()==3 and target_attributions.dim()==4 and attributions.shape[0]==target_attributions.shape[0] and attributions.shape[1]==target_attributions.shape[2] and attributions.shape[2]==target_attributions.shape[3]:\n                           target_attributions = target_attributions[:,-1,:,:] # 取目标的最后时间步\n                           print(\"Warning: Target attributions shape adjusted to match attributions (assuming last step)\")\n                      else:\n                           raise ValueError(\"Cannot automatically align shapes.\")\n                 except Exception as e:\n                      print(f\"Warning: Shape mismatch between attributions {attributions.shape} and target_attributions {target_attributions.shape}. Cannot compute supervised loss. Error: {e}\")\n                      target_attributions = None # 无法计算监督损失\n\n        if attr_loss_type == \'constraint\':\n            neg_attr_penalty = torch.relu(-attributions).mean()\n            sum_penalty = (torch.abs(attributions.sum(dim=-1) - 1.0)).mean()\n            loss_attr = neg_attr_penalty + sum_penalty\n        elif target_attributions is not None:\n            if attr_loss_type == \'mse\':\n                attr_loss_fn = nn.MSELoss()\n                loss_attr = attr_loss_fn(attributions, target_attributions)\n            elif attr_loss_type == \'kl_div\':\n                attr_loss_fn = nn.KLDivLoss(reduction=\'batchmean\')\n                loss_attr = attr_loss_fn(torch.log(attributions + 1e-9), target_attributions)\n        elif attr_loss_type != \'constraint\': # 如果类型不是约束但没有目标，则警告\n            print(f\"Warning: Cannot compute attribution loss type \'{attr_loss_type}\' without target_attributions.\")\n\n    # 3. 物理损失 (Physics Loss)\n    loss_physics = torch.tensor(0.0, device=device)\n    if lambda_physics > 0 and physics_residual is not None:\n        # 对齐物理残差和预测/目标 (它们应该已经对齐了，但再检查一下)\n        if physics_residual.shape != predictions.shape:\n            if physics_residual.dim() == 3 and predictions.dim() == 4 and predictions.shape[1] == 1:\
                 physics_residual = physics_residual.unsqueeze(1) # B, N, F -> B, 1, N, F\n            elif physics_residual.dim() == 4 and predictions.dim() == 3 and physics_residual.shape[1] == 1:\
                 physics_residual = physics_residual.squeeze(1) # B, 1, N, F -> B, N, F\n            else:\n                 try:\n                      if physics_residual.dim()==3 and predictions.dim()==4 and physics_residual.shape[0]==predictions.shape[0] and physics_residual.shape[1]==predictions.shape[2] and physics_residual.shape[2]==predictions.shape[3]:\n                           # 假设物理残差对应最后一步\n                           print(\"Warning: Assuming physics residual corresponds to the last prediction time step for loss calculation.\")\n                           # 不需要改变 physics_residual, 因为 predictions 已经被调整了 (如果需要的话)\n                           pass\n                      else:\n                           raise ValueError(\"Cannot automatically align shapes.\")\n                 except Exception as e:\
                      print(f\"Warning: Shape mismatch between physics_residual {physics_residual.shape} and predictions {predictions.shape}. Cannot compute physics loss. Error: {e}\")\n                      physics_residual = None # 无法计算\n\n        if physics_residual is not None:\n             loss_physics = torch.mean(physics_residual**2)\n\n    # 4. 组合损失\n    total_loss = loss_pred + lambda_attr * loss_attr + lambda_physics * loss_physics\n\n    return total_loss 